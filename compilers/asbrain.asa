;R0 is the data input and output
;R1 is the pointer to the value
;R2 is the content of R1
;R3 is the offset between R1 and the initialised array

DATA nl 10 0 ;A new line char

DATA standaloneASM1 "LAB start" 10 0 ;if we want to create a standalone program instead of a function
DATA standaloneASM2 "MOV R0 0" 10 0 ;If we want to run a standalone program we want to have the first element of the array as a 0
DATA standaloneNameASM "brainfuck" 0 ;the name of the label for the init
DATA standaloneASM3 "CALL brainfuck" 10 0 ;We go to the function
DATA standaloneASM4 "QUIT" 10 0;We end the program

DATA initASM1 "LAB " 0;Label to determine
DATA initASM2 "PUSH R1" 10 0;We store the values
DATA initASM3 "PUSH R2" 10 0
DATA initASM4 "PUSH R3" 10 0
DATA initASM5 "ASK_BYTE R1 X100000" 10 0;We ask for the bytes for the array
DATA initASM6 "MOV R3 0" 10 0
DATA initASM7 "MOV R2 R0"  10 0;We put the input value into R2
DATA initASM8 "STR_BYTE R1 R2 " 59 "start of the brainfuck program" 10 0 ;We store that value

DATA endASM1 "SUB R1 R3 " 59 "end of the brainfuck program" 10 0 ;We get to the start of the array
DATA endASM2 "LDR_BYTE R0 R1" 10 0 ;We put the output value into R0
DATA endASM3 "FREE R1" 10 0 ;We free the array to continue the programm
DATA endASM4 "POP R3" 10 0 ;We restore the registers
DATA endASM5 "POP R2" 10 0
DATA endASM6 "POP R1" 10 0
DATA endASM7 "RET" 10 0 ;We end the function

DATA +ASM1 "ADD R2 1 " 59 "+" 10 0 ;We increment the current value
DATA +ASM2 "AND R2 XFF" 10 0;We ensure that we are simply using byte and not 64 bits numbers
DATA +ASM3 "STR_BYTE R1 R2" 10 0 ;We store that value

DATA -ASM1 "SUB R2 1 " 59 "-" 10 0 ;We decrement the current value
DATA -ASM2 "AND R2 XFF" 10 0;We ensure that we are simply using byte and not 64 bits numbers
DATA -ASM3 "STR_BYTE R1 R2" 10 0 ;We store that value

DATA <ASM1 "CMP R3 0 " 59 "<" 10 0 ;We check if we will run out of space
DATA <ASM2 "JSE errorOOB" 10 0 ;if it is the case we jump out
DATA <ASM3 "SUB R1 1" 10 0 ;we move the pointer to the right position
DATA <ASM4 "SUB R3 1" 10 0 ;we update the offset
DATA <ASM5 "LDR_BYTE R2 R1" 10 0 ;we load the current value

DATA >ASM1 "CMP R3 XFFFFF " 59 ">" 10 0 ;We check if we will run out of space
DATA >ASM2 "JBE errorOOB" 10 0 ;if it is the case we jump out
DATA >ASM3 "ADD R1 1" 10 0 ;we move the pointer to the right position
DATA >ASM4 "ADD R3 1" 10 0 ;we update the offset
DATA >ASM5 "LDR_BYTE R2 R1" 10 0 ;we load the current value

DATA [ASM1 "CMP R2 0 " 59 "[" 10 0 ;we do the comparaison
DATA [ASM2 "JZ " 0 ;if the content of the cell is zero we go to the next bracket

DATA ]ASM1 "CMP R2 0 " 59 "]" 10 0 ;we do the comparaison
DATA ]ASM2 "JNZ " 0 ;if the content of the cell is not zero we have to redo the content of the brackets

DATA .ASM1 "PCHAR R2 " 59 "." 10 0 ;a simple print
;DATA .ASM1 "DSP R2 " 59 "." 10 0 ;This is ment for debugging. Comment the previous line and uncomment this one to print numbers instead of char

DATA ,ASM1 "GCHAR R2 " 59 "," 10 0 ;We ask for input
DATA ,ASM2 "STR_BYTE R1 R2" 10 0 ;We store the value

DATA errorOOBASM1 "LAB errorOOB" 10 0 ;We define a label for the error handeling
DATA errorOOBASM2 "DATA errormessage " 34 "Error: reaching bound of the array." 34 " 10 0 " 10 0 ;we need an error message
DATA errorOOBASM3 "LDR_DATA errormessage R3" 10 0 ;we load it
DATA errorOOBASM4 "STRLEN R4 R3" 10 0 ;we check it's size to print it
DATA errorOOBASM5 "STDERR R2" 10 0
DATA errorOOBASM6 "WRITE R2 R3 R4" 10 0 ;we print it to stderr
DATA errorOOBASM7 "QUIT 1" 10 0 ;we exit the program

;----------------------------------------------
;R0 is used to store the file descriptor for the input file
;R1 is used to store the file descriptor for the outpt file
;R3 is used to store the string we will print next
;R4 is used to store the name of the function the brainfuck code will conpile to

;The stack is used to store the labels of the brackets
;R10 is used to store the curent number of the bracket
;R11 is used to store the current depth into brackets
;R12 is used to store a string corresponding to usefull labels
;R13 is used as a temp value to store the top of the stack
DATA labASM "LAB " 0 ;Used signal a label to be filled
DATA labInASM "_IN" 10 0 ;used for entry in bracket labels
DATA labOutASM "_OUT" 10 0 ; used for exiting brackets labels

;R22 R23 and R24 are used to read a byte from the input file

;a test
LAB start
    DATA inputFile "in.brk" 0
    DATA outputFile "out.asa" 0
    LDR_DATA standaloneNameASM R4 
    LDR_DATA inputFile R20
    LDR_DATA outputFile R21
    OPEN R0 R20 0
    OPEN R1 R21 1
    CALL readFileASM
    CALL errorOOBASM
    CALL standaloneASM
    QUIT

;read a file whose name is in R20 and put the result in a file whose name is in R21
FUNC readFileASM
    OPEN R0 R20 0
    OPEN R1 R21 1
    MOV R10 0 ;REGISTERS init
    MOV R11 0 ;//
    ASK_BYTE R22 1 ;//
    CALL initASM
    LAB readingAchar
        EOFCMP R0 ;did we read the whole file
        JZ efA
        CALL readCharASM
        JMP readingAchar
    LAB efA
    CALL endASM
    RET 
   
FUNC readCharASM
    MOV R23 1 ;In a first time we load the character into R24
    READ R22 R0 R23
    LDR_BYTE R24 R22
    CMP R24 43 ;is it a +
    JZ rcA+
    CMP R24 45 ;is it a -
    JZ rcA-
    CMP R24 60 ;is it a <
    JZ rcA<
    CMP R24 62 ;is it a >
    JZ rcA>
    CMP R24 91 ;is it a [
    JZ rcA[
    CMP R24 93 ;is it a ]
    JZ rcA]
    CMP R24 46 ;is it a .
    JZ rcA.
    CMP R24 44 ;is it a ,
    JZ rcA,
    RET ;nothing found in this char
    LAB rcA+
        CALL +ASM
        RET
    LAB rcA-
        CALL -ASM
        RET
    LAB rcA<
        CALL <ASM
        RET
    LAB rcA>
        CALL >ASM
        RET
    LAB rcA[
        CALL [ASM
        RET
    LAB rcA]
        CALL ]ASM
        RET
    LAB rcA.
        CALL .ASM
        RET
    LAB rcA,
        CALL ,ASM
        RET
    
;---------------------------------------------------------------
;Encoding functions

;Used to encode , char
FUNC +ASM
    LDR_DATA +ASM1 R3
    CALL PRINT
    LDR_DATA +ASM2 R3
    CALL PRINT
    LDR_DATA +ASM3 R3
    CALL PRINT
    RET

;Used to encode - char
FUNC -ASM
    LDR_DATA -ASM1 R3
    CALL PRINT
    LDR_DATA -ASM2 R3
    CALL PRINT
    LDR_DATA -ASM3 R3
    CALL PRINT
    RET

;Used to encode < char
FUNC <ASM
    LDR_DATA <ASM1 R3
    CALL PRINT
    LDR_DATA <ASM2 R3
    CALL PRINT
    LDR_DATA <ASM3 R3
    CALL PRINT
    LDR_DATA <ASM4 R3
    CALL PRINT
    LDR_DATA <ASM5 R3
    CALL PRINT
    RET

;Used to encode > char
FUNC >ASM
    LDR_DATA >ASM1 R3
    CALL PRINT
    LDR_DATA >ASM2 R3
    CALL PRINT
    LDR_DATA >ASM3 R3
    CALL PRINT
    LDR_DATA >ASM4 R3
    CALL PRINT
    LDR_DATA >ASM5 R3
    CALL PRINT
    RET

;Used to encode the init sequence
FUNC initASM
    LDR_DATA initASM1 R3
    CALL PRINT
    MOV R3 R4 ;We get the name of the function
    CALL PRINT
    LDR_DATA nl R3 ;we gi to a new line
    CALL PRINT
    LDR_DATA initASM2 R3
    CALL PRINT
    LDR_DATA initASM3 R3
    CALL PRINT
    LDR_DATA initASM4 R3
    CALL PRINT
    LDR_DATA initASM5 R3
    CALL PRINT
    LDR_DATA initASM6 R3
    CALL PRINT
    LDR_DATA initASM7 R3
    CALL PRINT
    LDR_DATA initASM8 R3
    CALL PRINT
    RET
 
;Use to start a standalone brainfuck program
FUNC standaloneASM
    LDR_DATA standaloneASM1 R3
    CALL PRINT
    LDR_DATA standaloneASM2 R3
    CALL PRINT
    LDR_DATA standaloneASM3 R3
    CALL PRINT
    LDR_DATA standaloneASM4 R3
    CALL PRINT
    RET

;Used to encode the exit sequence
FUNC endASM
    LDR_DATA endASM1 R3
    CALL PRINT
    LDR_DATA endASM2 R3
    CALL PRINT
    LDR_DATA endASM3 R3
    CALL PRINT
    LDR_DATA endASM4 R3
    CALL PRINT
    LDR_DATA endASM5 R3
    CALL PRINT
    LDR_DATA endASM6 R3
    CALL PRINT
    LDR_DATA endASM7 R3
    CALL PRINT
    RET

;Used to encode the error sequence
FUNC errorOOBASM
    LDR_DATA errorOOBASM1 R3
    CALL PRINT
    LDR_DATA errorOOBASM2 R3
    CALL PRINT
    LDR_DATA errorOOBASM3 R3
    CALL PRINT
    LDR_DATA errorOOBASM4 R3
    CALL PRINT
    LDR_DATA errorOOBASM5 R3
    CALL PRINT
    LDR_DATA errorOOBASM6 R3
    CALL PRINT
    LDR_DATA errorOOBASM7 R3
    CALL PRINT
    RET

;Used to encode [ char
FUNC [ASM
    ADD R10 1 ;We update register controling the brackets
    ADD R11 1
    NTS R12 R10 ;We generate a label name
    LDR_DATA labASM R3 ;We start to write the label
    CALL PRINT
    MOV R3 R12 ;We happend the number
    CALL PRINT
    LDR_DATA labInASM R3 ;We put the sufix
    CALL PRINT
    LDR_DATA [ASM1 R3
    CALL PRINT
    LDR_DATA [ASM2 R3
    CALL PRINT
    MOV R3 R12 ;We happend the number
    CALL PRINT
    LDR_DATA labOutASM R3 ;We put the sufix
    CALL PRINT
    PUSH R10 ;We store the number to use it when leaving the brackets
    RET

;Used to encode ] char
FUNC ]ASM
    ADD R11 1 ;We update register controling the brackets
    POP R13
    NTS R12 R13 ;We generate a label name
    LDR_DATA labASM R3 ;We start to write the label
    CALL PRINT
    MOV R3 R12 ;We happend the number
    CALL PRINT
    LDR_DATA labOutASM R3 ;We put the sufix
    CALL PRINT
    LDR_DATA ]ASM1 R3
    CALL PRINT
    LDR_DATA ]ASM2 R3
    CALL PRINT
    MOV R3 R12 ;We happend the number
    CALL PRINT
    LDR_DATA labInASM R3 ;We put the sufix
    CALL PRINT
    RET

;Used to encode . char
FUNC .ASM
    LDR_DATA .ASM1 R3
    CALL PRINT
    RET

;Used to encode , char
FUNC ,ASM
    LDR_DATA ,ASM1 R3
    CALL PRINT
    LDR_DATA ,ASM2 R3
    CALL PRINT
    RET
   

;Print into the file in R1 a string in R0
FUNC PRINT
    PUSH R0 ;Used to get the length of the string to print
    STRLEN R0 R3
    WRITE R1 R3 R0
    POP R0
    RET
